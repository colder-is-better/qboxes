#!/bin/bash

red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)

bold=$(tput bold)
regular=$(tput sgr0)

# ---------------------------------------------------------------------------
# show_usage():
#   Displays general usage information,
#   Provides help on the syntax of each supported command
# ---------------------------------------------------------------------------

show_usage() {
  help_for=$1
  error_code=$2
  case $help_for in
    activate)
      printf "COMMAND NAME\\n"
      printf "  activate - activate inactive libvirt entities\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  activate <vm(s)|network(s)|pool(s)>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Activate inactive libvirt entities, where \"entity\" may"
      printf " be any one of vm, network, pool\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes activate vms leap423 sles11sp4%s\\n\\n" "$bold" "$regular"
      printf "  ~> %sqboxes activate networks localnet coolernet%s\\n\\n" "$bold" "$regular"
      printf "  ~> %sqboxes activate pools ceph ostack tank%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    activate-vms)
      printf "COMMAND NAME & OBJECTS\\n"
      printf "  activate - activate given inactive VMs\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  activate vms <inactive_VM_1> ... <inactive_VM_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Activate one or more inactive VMs\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes activate vms leap423 sles11sp4%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    activate-networks)
      printf "COMMAND NAME & OBJECTS\\n"
      printf "  activate - activate given inactive networks\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  activate networks <inactive_net_1> ... <inactive_net_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Activate one or more inactive libvirt networks\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes activate networks localnet coolernet%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    activate-pools)
      printf "COMMAND NAME & OBJECTS\\n"
      printf "  activate - activate given inactive pools\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  activate pools <inactive_pool_1> ... <inactive_pool_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Activate one or more inactive storage pools\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes activate pools ceph ostack tank%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    annihilate)
      printf "COMMAND NAME\\n"
      printf "  annihilate - remove any trace of given libvirt entities\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  annihilate <vm(s)|network(s)|pool(s)|volume(s)>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Delete libvirt entities, where \"entity\" may"
      printf " be any one of vm, network, pool, volume\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes annihilate vms node{1..8}%s\\n\\n" "$bold" "$regular"
      printf "  ~> %sqboxes annihilate networks qbxnet localnet%s\\n\\n" "$bold" "$regular"
      printf "  ~> %sqboxes annihilate pools templates tank%s\\n\\n" "$bold" "$regular"
      printf "  ~> %sqboxes annihilate volumes --from-pool=datastore disk{0..4}.qcow2%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    annihilate-vms)
      printf "COMMAND NAME & OBJECTS\\n"
      printf "  annihilate vm - remove any trace of given inactive VMs\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  annihilate vm <inactive_VM_1> ... <inactive_VM_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Delete one or more inactive VMs\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes annihilate vm node{1..8}%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    annihilate-networks)
      printf "COMMAND NAME & OBJECTS\\n"
      printf "  annihilate network - remove given inactive libvirt networks\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  annihilate network <active_net_1> ... <active_net_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Delete one or more inactive libvirt networks\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes annihilate network qbxnet localnet%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    annihilate-pools)
      printf "COMMAND NAME & OBJECTS\\n"
      printf "  annihilate pool - remove given inactive storage pools\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  annihilate pool <inactive_pool_1> ... <inactive_pool_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Delete one or more inactive storage pools\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes annihilate pool templates tank%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    annihilate-volumes)
      printf "COMMAND NAME & OBJECTS\\n"
      printf "  annihilate volume - remove storage volumes\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  annihilate volume --from-pool=<active_pool_name> <vol_1> ... <vol_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Delete one or more storage volumes from given active pool\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes annihilate volume --from-pool=datastore disk{0..4}.qcow2%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    assimilate)
      printf "COMMAND NAME\\n"
      printf "  assimilate - integrate storage volumes into an active storage pool\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  assimilate --pool=<active_pool_name> <vol_1> ... <vol_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Copy, if necessary, one or more storage volumes (files of type ISO, QCOW2, etc.)\\n"
      printf "  to an active storage pool, refresh the pool if necessary\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes assimilate --pool=templates /tmp/packer_out/leap423.qcow2 ./bionic-beaver.qcow2%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    attach)
      printf "COMMAND NAME\\n"
      printf "  attach - attach a storage volume to an (in)active VM\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  attach --volume=<file_name> --from-pool=<active_pool_name> <VM_name>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Attach a storage volume from given active pool, to an (in)active VM\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes attach --volume=datadisk.qcow2 --from-pool=storage fileserver%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    check-service)
      printf "COMMAND NAME\\n"
      printf "  check-service - attempt to connect to specified TCP port of one or more active VMs\\n\\n"
      printf "SYNOPSIS\\n";
      printf "  check-service --port=<tcp_port> <active_VM_1> ... <active_VM_k>\\n\\n";
      printf "DESCRIPTION\\n";
      printf "  Check if one or more active VMs are reachable via specificied TCP port\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes check-service --port=22 masternode%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    clone)
      printf "COMMAND NAME\\n"
      printf "  clone - clone a template VM into one or more new VMs\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  clone --template=<VM_0> --target-pool=<the_same|active_pool_name> <VM_1> ... <VM_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Clone an inactive template VM into one or more new VMs,\\n"
      printf "  indicate a target active pool for keeping the cloned volumes\\n"
      printf "  * In --target_pool=..., %sthe_same%s is a literal\\n" "$bold" "$regular"
      printf "    and active_pool_name is a placeholder\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes clone --template=sles12sp3vm --target-pool=cloudlab" "$bold"
      printf " httpsrv{1,2} balancer%s\\n\\n" "$regular"
      exit "$error_code"
    ;;
    create)
      printf "COMMAND NAME\\n"
      printf "  create - create a new libvirt entity\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  create <network|pool|volume>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Create a new libvirt entity, where \"entity\" may"
      printf " be any one of network, pool, volume\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes create network --type=nated --name=vnet --domain=local.qbx \\" "$bold"
      printf "\\n       --router=10.20.30.254 --netmask=255.255.255.0 \\"
      printf "\\n       --dhcp=on --from=10.20.30.100 --to=10.20.30.253%s\\n\\n" "$regular"
      printf "  ~> %sqboxes create pool --name=ceph --path=/usr/local/testing/storage-cluster%s\\n\\n" "$bold" "$regular"
      printf "  ~> %sqboxes create volume --name=datadisk.qcow2 --size=1024 --pool=tank%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    create-network)
      printf "COMMAND NAME & OBJECT\\n"
      printf "  create network - create a new libvirt network\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  create network --type=<nated|isolated> --name=<net_name> --domain=<domain.name> --router=<router.ip.v4.address>"
      printf " --netmask=<netmask.ip.v4.addr> --dhcp=<on|off> [--from=<from.ip.v4.addr>] [--to=<to.ip.v4.addr>]\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Create a new libvirt network, optionally offering routing and DNS"
      printf " services, and DHCP services also\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes create network --type=nated --name=vnet --domain=local.qbx \\" "$bold"
      printf "\\n       --router=10.20.30.254 --netmask=255.255.255.0 \\"
      printf "\\n       --dhcp=on --from=10.20.30.100 --to=10.20.30.253%s\\n\\n" "$regular"
      exit "$error_code"
    ;;
    create-pool)
      printf "COMMAND NAME & OBJECT\\n"
      printf "  create pool - create a new storage pool\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  create pool --name=<pool_name> --path=<path_to_local_dir>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Create a new storage pool with given name, connected to local path\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes create pool --name=ceph --path=/usr/local/testing/storage-cluster%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    create-volume)
      printf "COMMAND NAME & OBJECT\\n"
      printf "  create volume - create a new storage volume\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  create volume --name=<volume_file_name> --size=<size_in_GiB> --pool=<active_pool>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Create a new storage volume with given name and size, under active storage pool\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes create volume --name=datadisk.qcow2 --size=1024 --pool=tank%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    deactivate)
      printf "COMMAND NAME\\n"
      printf "  deactivate - deactivate active libvirt entities\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  deactivate <vm(s)|network(s)|pool(s)>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Deactivate active libvirt entities, where \"entity\" may"
      printf " be any one of vm, network, pool\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes deactivate vms node{1..5}%s\\n\\n" "$bold" "$regular"
      printf "  ~> %sqboxes deactivate network cephnet%s\\n\\n" "$bold" "$regular"
      printf "  ~> %sqboxes deactivate pools ceph ostack%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    deactivate-vms)
      printf "COMMAND NAME & OBJECTS\\n"
      printf "  deactivate - gracefully shutdown given active VMs\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  deactivate vms <active_vm_1> ... <active_vm_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Gracefully shutdown one or more active VMs\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes deactivate vms node{1..5}%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    deactivate-networks)
      printf "COMMAND NAME & OBJECTS\\n"
      printf "  deactivate - deactivate given active libvirt networks\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  deactivate networks <active_net_1> ... <active_net_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Deactivate one or more active libvirt networks\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes deactivate network cephnet%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    deactivate-pools)
      printf "COMMAND NAME & OBJECTS\\n"
      printf "  deactivate - deactivate given active storage pools\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  deactivate pools <active_pool_1> ... <active_pool_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Deactivate one or more active storage pools\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes deactivate pools ceph ostack%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    define)
      printf "COMMAND NAME\\n"
      printf "  define - define a new VM\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  define --ram=<size_in_MiB> --cores=<count> --osdisk=<volume_name> --from-pool=<active_pool_name>"
      printf " --network=<host_bridge|libvirt_net_name> --mac=<auto|MAC_address> --guest-os=<os_variant> <VM_name>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Define a new VM according to specifications, do not install a guest OS\\n"
      printf "  * In --network=..., %shost_bridge%s is a literal and libvirt_net_name is a placeholder\\n" "$bold" "$regular"
      printf "  * In --mac=..., %sauto%s is a literal and MAC_address is a placeholder\\n" "$bold" "$regular"
      printf "  * Type %sosinfo-query os%s for a list of all the supported OS variants\\n\\n" "$bold" "$regular"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes define --ram=2048 --cores=2 \\" "$bold"
      printf "\\n       --osdisk=leap423.qcow2 --from-pool=tank \\"
      printf "\\n       --network=vnet --mac=auto \\"
      printf "\\n       --guest-os=opensuse42.3 leap423vm%s\\n\\n" "$regular"
      exit "$error_code"
    ;;
    getmac)
      printf "COMMAND NAME\\n"
      printf "  getmac - reveal MAC addresses\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  getmac <VM_1> ... <VM_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Reveal the first Ethernet adapter's MAC address of one or more (in)active VMs\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes getmac sles12sp{1,2,3}vm%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    list)
      printf "COMMAND NAME\\n"
      printf "  list - present all available entities of given type\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  list <vm(s)|network(s)|pool(s)|volume(s)>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Present all available (in)active entities of given type,\\n"
      printf "  where \"type\" may be any one of vm, network, pool, volume.\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes list vms%s\\n\\n" "$bold" "$regular"
      printf "  ~> %sqboxes list networks%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    ping)
      printf "COMMAND NAME\\n"
      printf "  ping - send ICMP packets to active VMs\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  ping --count=<number_of_packets> <active_VM_1> ... <active_VM_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Send a specified number of ICMP packets to one or more active VMs\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes ping --count=3 sles12sp3 debstrech%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    powcycle)
      printf "COMMAND NAME\\n"
      printf "  powcycle - cold-restart active VMs\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  powcycle <active_VM_1> ... <active_VM_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Cold-restart one or more active VMs\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes powcycle srv1 srv2%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    reboot)
      printf "COMMAND NAME\\n";
      printf "  reboot - gracefully restart active VMs\\n\\n";
      printf "SYNOPSIS\\n";
      printf "  reboot <active_VM_1> ... <active_VM_k>\\n\\n";
      printf "DESCRIPTION\\n";
      printf "  Try to gracefully restart one or more active VMs\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes reboot sles12sp3%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    unplug)
      printf "COMMAND NAME\\n"
      printf "  unplug - force-shutdown active VMs\\n\\n"
      printf "SYNOPSIS\\n"
      printf "  unplug <active_VM_1> ... <active_VM_k>\\n\\n"
      printf "DESCRIPTION\\n"
      printf "  Force-power-off one or more active VMs\\n\\n"
      printf "%sEXAMPLE%s\\n" "$bold" "$regular"
      printf "  ~> %sqboxes unplug guest{1..3}%s\\n\\n" "$bold" "$regular"
      exit "$error_code"
    ;;
    *)
      printf "\\nThis is %sqboxes%s, a simple command line tool" "$green" "$regular"
      printf " for managing local QEMU/KVM VMs.\\n"
      printf "The following commands are currently implemented:\\n\\n"
      printf "  activate\\t: bring inactive VMs up, or activate inactive libvirt networks, storage pools\\n"
      printf "  annihilate\\t: remove any trace of inactive VMs, libvirt networks, storage pools, or volumes\\n"
      printf "  assimilate\\t: integrate storage volumes into an active pool\\n"
      printf "  attach\\t: attach a storage volume to an (in)active VM\\n"
      printf "  check-service\\t: try to connect to specified TCP port of one or more active VMs\\n"
      printf "  clone\\t\\t: clone a template VM into one or more new VMs\\n"
      printf "  create\\t: create a new libvirt network, storage pool, or volume\\n"
      printf "  deactivate\\t: gracefully shutdown active VMs, or deactivate active libvirt networks, storage pools\\n"
      printf "  define\\t: define a new VM according to specs, do not install a guest OS\\n"
      printf "  getmac\\t: reveal VM MAC addresses\\n"
      printf "  list\\t\\t: present all available VMs, libvirt networks, storage pools, or volumes\\n"
      printf "  ping\\t\\t: send ICMP packets to active VMs\\n"
      printf "  powcycle\\t: cold-restart active VMs\\n"
      printf "  reboot\\t: gracefully restart active VMs\\n"
      printf "  unplug\\t: force-power-off active VMs\\n\\n"
      printf "  help\\t\\t: display this summary of commands\\n"
      printf "  command help\\t: get help on specific command\\n\\n"
      printf "Type %sqboxes command help%s for the syntax" "$green" "$regular"
      printf " and a usage example of a specific command.\\n\\n"
      exit "$error_code"
    ;;
  esac
}

# ---------------------------------------------------------------------------
# is_name_valid():
#   Checks if given name is valid
#   A name is valid for qboxes if it comprises alphanumerics,
#   hyphens, underscores and dots only, does not start with
#   a hyphen and is between 1 and 63 characters long
# ---------------------------------------------------------------------------

is_name_valid() {
  answer="no"
  the_name="$1"
  length=${#the_name}
  if [ "$the_name" != "host_bridge" ] && [ "$the_name" != "the_same" ] \
  && [ "${the_name:0:1}" != "-" ] && [ "$length" -gt 0 ] && [ "$length" -le 63 ]; then
    valid_name_test=$(echo "$the_name" | tr -d "[:alnum:]-_.")
    if [ -z "$valid_name_test" ]; then
      answer="yes"
    fi
  fi
  echo "$answer"
}

# ---------------------------------------------------------------------------
# is_number_valid():
#   Checks if given number is valid
#   A number is valid for qboxes if it comprises numeric
#   characters only (no signs, commas, dots, units, or any other character) 
# ---------------------------------------------------------------------------

is_number_valid() {
  answer="no"
  the_number="$1"
    if [ -n "$the_number" ]; then
      valid_number_test=$(echo "$the_number" | tr -d "[:digit:]")
      if [ -z "$valid_number_test" ]; then
      answer="yes"
      fi
    fi
  echo "$answer"
}

# ---------------------------------------------------------------------------
# is_size_valid():
#   Checks if given size (of either RAM or volume) is valid
#   Given size is valid if it's between size_min and size_max
#   inclusive, and is also an integer multiple of size_min
# ---------------------------------------------------------------------------

is_size_valid() {
  answer="yes"
  the_value="$1"
  size_min="$2"
  size_max="$3"
  if [ "$the_value" -lt "$size_min" ] \
  || [ "$the_value" -gt "$size_max" ] \
  || [ $((the_value % size_min)) -gt 0 ]; then
    answer="no"
  fi
  echo "$answer"
}

# ---------------------------------------------------------------------------
# is_mac_valid():
#   Checks if given string represents a valid MAC address
# ---------------------------------------------------------------------------

is_mac_valid() {
  answer="no"
  the_mac="$1"
  the_mac_caps=${the_mac^^}
  valid_mac_regexp="([0-9A-F]{2}:){5}[0-9A-F]{2}$"
  valid_mac_test="$(echo "$the_mac_caps" | grep -E "^$valid_mac_regexp")"
  if [ -n "$valid_mac_test" ]; then
    answer="yes"
  fi
  echo "$answer"
}

# ---------------------------------------------------------------------------
# is_ipv4_valid():
#   Checks if given string represents a valid IPv4 address
# ---------------------------------------------------------------------------

is_ipv4_valid() {
  answer="no"
  the_address="$1"
  zero_to_255="(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
  valid_ipv4_regex="$zero_to_255"\."$zero_to_255"\."$zero_to_255"\."$zero_to_255"
  valid_ipv4_test=$(echo "$the_address" | grep -E "^$valid_ipv4_regex")
  if [ -n "$valid_ipv4_test" ]; then
    answer="yes"
  fi
  echo "$answer"
}

# ---------------------------------------------------------------------------
# is_a_member():
#   Checks if given string matches a member of a sequence of strings
# ---------------------------------------------------------------------------

is_a_member() {
  answer="no"
  item="$1"
  the_set="$2"
  for each_one in $the_set; do
    if [ "$item" == "$each_one" ]; then
      answer="yes"
      break
    fi
  done
  echo "$answer"
}

# ---------------------------------------------------------------------------
# left_part_of():
#   Returns the left part of a string, in relation to a given substring
# ---------------------------------------------------------------------------

left_part_of() {
  input_string="$1"
  the_mark="$2"
  left_part="$(echo "$input_string" | awk -F "$the_mark" '{ print $1 }')"
  echo "$left_part"
}

# ---------------------------------------------------------------------------
# right_part_of():
#   Returns the right part of a string, in relation to a given substring
# ---------------------------------------------------------------------------

right_part_of() {
  input_string="$1"
  the_mark="$2"
  right_part="$(echo "$input_string" | awk -F "$the_mark" '{ print $2 }')"
  echo "$right_part"
}

# ---------------------------------------------------------------------------
# in_between():
#   Returns the part of a string which is between two given substrings
# ---------------------------------------------------------------------------

in_between() {
  input_string="$1"
  left_mark="$2"
  right_mark="$3"
  right_part="$(right_part_of "$input_string" "$left_mark")"
  middle_part="$(left_part_of "$right_part" "$right_mark")"
  echo "$middle_part"
}

# ---------------------------------------------------------------------------
# get_random_alphanum():
#   Returns a random string of alphanumeric characters
# ---------------------------------------------------------------------------

get_random_alphanum() {
  echo "$(strings /dev/urandom | grep -o '[[:alnum:]]' | head -n 48 | tr -d '\n')"
}

# ---------------------------------------------------------------------------
# get_bridge_gw_dev():
#   Returns the bridge host device that is also the default gateway
# ---------------------------------------------------------------------------

get_bridge_gw_dev() {
  bridge_gw_dev="$(sudo brctl show | grep -E "^$(sudo route -n | grep "UG" \
  | grep -v "UGH" | awk '{ print $8 }')" | awk '{ print $1 }')"
  if [ -z "$bridge_gw_dev" ]; then
    bridge_gw_dev="n/a"
  fi
  echo "$bridge_gw_dev"
}

# ---------------------------------------------------------------------------
# get_canonical_mac():
#   Replaces, if necessary, the manufacturer part of given
#   MAC address with the given manufacturer code
# ---------------------------------------------------------------------------

get_canonical_mac() {
  the_mac="$1"
  manufacturer_code="$2"
  manufacturer_part="${the_mac:0:8}"
  if [ "$manufacturer_part" != "$manufacturer_code" ]; then
    hardware_part="${the_mac:9:17}"
    the_mac="$manufacturer_code":"$hardware_part"
  fi
  echo "$the_mac"
}

# ---------------------------------------------------------------------------
# get_first_nic_mac():
#   Returns the MAC address of a VM's first Ethernet adapter
# ---------------------------------------------------------------------------

get_first_nic_mac() {
  the_vm="$1"
  line_in_xml="$(virsh --quiet dumpxml "$the_vm" | grep "mac address" | head -n 1)"
  first_nic_mac="$(in_between "$line_in_xml" "<mac address='" "'")"
  echo "$first_nic_mac"
}

# ---------------------------------------------------------------------------
# get_first_nic_net():
#   Returns the name or the connection type of given VM's first net adapter
# ---------------------------------------------------------------------------

get_first_nic_net() {
  the_vm="$1"
  first_nic_net="n/a"
  line_in_xml="$(virsh --quiet dumpxml "$the_vm" | grep "<source bridge='" | head -n 1)"
  if [ -n "$line_in_xml" ]; then
    first_nic_net="hostBridge"
  else
    line_in_xml="$(virsh --quiet dumpxml "$the_vm" | grep "<source network='" | head -n 1)"
    if [ -n "$line_in_xml" ]; then
      first_nic_net="$(in_between "$line_in_xml" "<source network='" "'")"
    fi
  fi
  echo "$first_nic_net"
}

# ---------------------------------------------------------------------------
# get_first_nic_ip():
#   Returns the IPv4 address of a VM's first network adapter
# ---------------------------------------------------------------------------

get_first_nic_ip() {
  the_vm="$1"
  first_nic_ip="n/a"
  first_nic_net=$(get_first_nic_net "$the_vm")
  if [ "$first_nic_net" != "n/a" ]; then
    first_nic_ip="unknown"
    first_nic_mac=$(get_first_nic_mac "$the_vm")
    via_guest_agent="$(virsh domifaddr --source agent "$the_vm" 2> /dev/null | grep "$first_nic_mac" | grep -v "N/A" | awk '{ print $4 }')"
    if [ -n "$via_guest_agent" ]; then
      first_nic_ip=$(left_part_of "$via_guest_agent" "/")
    elif [ "$first_nic_net" != "hostBridge" ]; then
      via_local_dhcp="$(virsh domifaddr --source lease "$the_vm" 2> /dev/null | grep "$first_nic_mac" | awk '{ print $4 }')"
      if [ -n "$via_local_dhcp" ]; then
        first_nic_ip="$(left_part_of "$via_local_dhcp" "/")"
      fi
    fi
  fi
  echo "$first_nic_ip"
}

# ---------------------------------------------------------------------------
# get_volumes():
#   Returns all volumes in given pool
# ---------------------------------------------------------------------------

get_volumes() {
  the_pool="$1"
  the_volumes=$(virsh vol-list "$the_pool" | grep " /" | awk '{ print $1 }')
  echo "$the_volumes"
}

# ---------------------------------------------------------------------------
# get_pools():
#   Returns active, inactive or all pools
#   Implemented for compatibility reasons (old versions
#   of virsh do not understand the --name option)
# ---------------------------------------------------------------------------

get_pools() {
  state="$1"
  case $state in
    all)
      the_pools="$(virsh pool-list --all | grep "active" | awk '{ print $1 }')"
    ;;
    active)
      the_pools="$(virsh pool-list --all | grep -w "active" | awk '{ print $1 }')"
    ;;
    inactive)
      the_pools="$(virsh pool-list --all | grep "inactive" | awk '{ print $1 }')"
    ;;
    *)
      the_pools=""
    ;;
  esac
  echo "$the_pools"
}

# ---------------------------------------------------------------------------
# get_networks():
#   Returns active, inactive or all libvirt networks
#   Implemented for compatibility reasons (old versions
#   of virsh do not understand the --name option)
# ---------------------------------------------------------------------------

get_networks() {
  state="$1"
  case $state in
    all)
      the_networks="$(virsh net-list --all | grep "active" | awk '{ print $1 }')"
    ;;
    active)
      the_networks="$(virsh net-list --all | grep -w "active" | awk '{ print $1 }')"
    ;;
    inactive)
      the_networks="$(virsh net-list --all | grep "inactive" | awk '{ print $1 }')"
    ;;
    *)
      the_networks=""
    ;;
  esac
  echo "$the_networks"
}

# ---------------------------------------------------------------------------
# get_pool_path():
#   Returns the full path of given storage pool
# ---------------------------------------------------------------------------

get_pool_path() {
  the_pool="$1"
  the_path=$(in_between "$(virsh pool-dumpxml "$the_pool" | grep "<path>")" "<path>" "</path>")
  echo "$the_path"
}

# ---------------------------------------------------------------------------
# get_vm_vols():
#   Returns paths of all storage volumes
#   (VirtIO, IDE, SATA, or SCSI devices) of given VM
# ---------------------------------------------------------------------------

get_vm_vols() {
  the_vm="$1"
  the_storage_vols=$(virsh domblklist "$the_vm" | grep -E '^(vd|sd|hd)')
  echo "$the_storage_vols"
}

# ---------------------------------------------------------------------------
# get_vm_blk_num():
#   Returns number of all storage volumes
#   (VirtIO, IDE, SATA, or SCSI devices) connected to given VM
# ---------------------------------------------------------------------------

get_vm_blk_num() {
  the_vm="$1"
  all_vm_vols=$(get_vm_vols "$the_vm")
  how_many=$(($(echo "$all_vm_vols" | wc -w) / 2))
  echo "$how_many"
}

# ---------------------------------------------------------------------------
# create_xml_net_isolated():
#   Returns the path to an XML file describing
#   a libvirt isolated network
# ---------------------------------------------------------------------------

create_xml_net_isolated() {
  net_name="$1"
  bridge_dev="$2"
  domain_name="$3"
  xml_net_isolated="/tmp/""$(get_random_alphanum)".xml
  echo "<network>" > "$xml_net_isolated"
  echo "  <name>""$net_name""</name>" >> "$xml_net_isolated"
  echo "  <bridge name='""$bridge_dev""' stp='on' delay='0'/>" >> "$xml_net_isolated"
  echo "  <domain name='""$domain_name""'/>" >> "$xml_net_isolated"
  echo "</network>" >> "$xml_net_isolated"
  echo "$xml_net_isolated"
}

# ---------------------------------------------------------------------------
# create_xml_net_nat_no_dhcp():
#   Returns the path to an XML file describing
#   a libvirt NAT network without DHCP support
# ---------------------------------------------------------------------------

create_xml_net_nat_no_dhcp() {
  net_name="$1"
  bridge_dev="$2"
  domain_name="$3"
  router_addr="$4"
  netmask_addr="$5"
  xml_net_nat_no_dhcp="/tmp/""$(get_random_alphanum)".xml
  echo "<network>" > "$xml_net_nat_no_dhcp"
  echo "  <name>""$net_name""</name>" >> "$xml_net_nat_no_dhcp"
  echo "  <forward mode='nat'>" >> "$xml_net_nat_no_dhcp"
  echo "    <nat>" >> "$xml_net_nat_no_dhcp"
  echo "      <port start='1024' end='65535'/>" >> "$xml_net_nat_no_dhcp"
  echo "    </nat>" >> "$xml_net_nat_no_dhcp"
  echo "  </forward>" >> "$xml_net_nat_no_dhcp"
  echo "  <bridge name='""$bridge_dev""' stp='on' delay='0'/>" >> "$xml_net_nat_no_dhcp"
  echo "  <domain name='""$domain_name""'/>" >> "$xml_net_nat_no_dhcp"
  echo "  <ip address='""$router_addr""' netmask='""$netmask_addr""'>" >> "$xml_net_nat_no_dhcp"
  echo "  </ip>" >> "$xml_net_nat_no_dhcp"
  echo "</network>" >> "$xml_net_nat_no_dhcp"
  echo "$xml_net_nat_no_dhcp"
}

# ---------------------------------------------------------------------------
# create_xml_net_nat_dhcp():
#   Returns the path to an XML file describing
#   a libvirt NAT network with DHCP support
# ---------------------------------------------------------------------------

create_xml_net_nat_dhcp() {
  net_name="$1"
  bridge_dev="$2"
  domain_name="$3"
  router_addr="$4"
  netmask_addr="$5"
  from_addr="$6"
  to_addr="$7"
  xml_net_nat_dhcp="/tmp/""$(get_random_alphanum)".xml
     echo "<network>" > "$xml_net_nat_dhcp"
  echo "  <name>""$net_name""</name>" >> "$xml_net_nat_dhcp"
  echo "  <forward mode='nat'>" >> "$xml_net_nat_dhcp"
  echo "    <nat>" >> "$xml_net_nat_dhcp"
  echo "      <port start='1024' end='65535'/>" >> "$xml_net_nat_dhcp"
  echo "    </nat>" >> "$xml_net_nat_dhcp"
  echo "  </forward>" >> "$xml_net_nat_dhcp"
  echo "  <bridge name='""$bridge_dev""' stp='on' delay='0'/>" >> "$xml_net_nat_dhcp"
  echo "  <domain name='""$domain_name""'/>" >> "$xml_net_nat_dhcp"
  echo "  <ip address='""$router_addr""' netmask='""$netmask_addr""'>" >> "$xml_net_nat_dhcp"
  echo "    <dhcp>" >> "$xml_net_nat_dhcp"
  echo "      <range start='""$from_addr""' end='""$to_addr""'/>" >> "$xml_net_nat_dhcp"
  echo "    </dhcp>" >> "$xml_net_nat_dhcp"
  echo "  </ip>" >> "$xml_net_nat_dhcp"
  echo "</network>" >> "$xml_net_nat_dhcp"
  echo "$xml_net_nat_dhcp"
}

# ---------------------------------------------------------------------------
# activate_vms_cmd():
#   Powers up one or more inactive VMs
# ---------------------------------------------------------------------------

activate_vms_cmd() {
  if [ "$1" == "help" ]; then
    echo
    show_usage activate-vms 0
  fi

  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage activate-vms 1
  fi

  all_inactive_VMs=$(virsh list --name --inactive 2> /dev/null)
  if [ -z "$all_inactive_VMs" ]; then
    printf "\\n%scannot seem to find a single inactive VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid VM name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_inactive_VMs")
      if [ "$answer" == "no" ]; then
        printf "%s'%s' is not an inactive VM%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%spowering up %s%s\\n" "$green" "$candidate" "$regular"
        virsh start "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d%s\\n" "$yellow" $virsh_ec "$regular"
        else
          sleep 1
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# activate_networks_cmd():
#   Activates one or more inactive libvirt networks
# ---------------------------------------------------------------------------

activate_networks_cmd()
{
  if [ "$1" == "help" ]; then
    echo
    show_usage activate-networks 0
  fi

  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage activate-networks 1
  fi

  all_inactive_networks=$(get_networks "inactive")
  if [ -z "$all_inactive_networks" ]; then
    printf "\\n%scannot seem to find a single inactive network on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid network name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_inactive_networks")
      if [ "$answer" == "no" ]; then
        printf "%s'%s' is not an inactive network%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%sactivating %s%s\\n" "$green" "$candidate" "$regular"
        virsh net-start "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d%s\\n" "$yellow" $virsh_ec "$regular"
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# activate_pools_cmd():
#   Activates one or more inactive storage pools
# ---------------------------------------------------------------------------

activate_pools_cmd()
{
  if [ "$1" == "help" ]; then
    echo
    show_usage activate-pools 0
  fi

  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage activate-pools 1
  fi

  all_inactive_pools=$(get_pools "inactive")
  if [ -z "$all_inactive_pools" ]; then
    printf "\\n%scannot seem to find a single inactive pool on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid pool name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_inactive_pools")
      if [ "$answer" == "no" ]; then
        printf "%s'%s' is not an inactive pool%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%sactivating %s%s\\n" "$green" "$candidate" "$regular"
        virsh pool-start "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d%s\\n" "$yellow" $virsh_ec "$regular"
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# activate_cmd():
#   Powers up inactive VMs,
#   activates inactive libvirt networks or storage pools
# ---------------------------------------------------------------------------

activate_cmd() {
  entity_type="$1"

  case $entity_type in
  vm|vms)
    shift
    activate_vms_cmd "$@"
  ;;
  network|net|networks|nets)
    shift
    activate_networks_cmd "$@"
  ;;
  pool|pools)
    shift
    activate_pools_cmd "$@"
  ;;
  "")
    printf "\\n%sentity type not specified%s\\n\\n" "$red" "$regular"
    show_usage activate 1
  ;;
  *)
    printf "\\n%sinvalid entity type '%s'%s\\n\\n" "$red" "$entity_type" "$regular"
    show_usage activate 1
  ;;
  esac
}

# ---------------------------------------------------------------------------
# annihilate_vms_cmd():
#   Removes any trace of one or more inactive VMs
# ---------------------------------------------------------------------------

annihilate_vms_cmd() {
  if [ "$1" == "help" ]; then
    echo
    show_usage annihilate-vms 0
  fi

  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage annihilate-vms 1
  fi

  all_inactive_VMs=$(virsh list --name --inactive 2> /dev/null)
  if [ -z "$all_inactive_VMs" ]; then
    printf "\\n%scannot seem to find a single inactive VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid VM name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_inactive_VMs")
      if [ "$answer" == "no" ]; then
        printf "%s'%s' is not an inactive VM%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%sannihilating %s%s\\n" "$green" "$candidate" "$regular"
        all_snapshots=$(virsh snapshot-list --name "$candidate")
        if [ -n "$all_snapshots" ]; then
          for each_one in $all_snapshots; do
            printf "%sdeleting snapshot '%s'%s\\n" "$green" "$each_one" "$regular"
            virsh snapshot-delete --domain "$candidate" --snapshotname "$each_one" > /dev/null 2>&1
            virsh_ec=$?
            if [ $virsh_ec -ne 0 ]; then
              printf \
                "%sfailed to delete snapshot '%s' of %s, virsh returned error code %d, terminating now%s\\n" \
                "$red" "$each_one" "$candidate" $virsh_ec "$regular"
              exit 2
            fi
          done
        fi
        virsh undefine "$candidate" --remove-all-storage --wipe-storage > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d, terminating now%s\\n" "$red" $virsh_ec "$regular"
          exit 2
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# annihilate_networks_cmd():
#   Removes any trace of one or more inactive libvirt networks
# ---------------------------------------------------------------------------

annihilate_networks_cmd() {
  if [ "$1" == "help" ]; then
    echo
    show_usage annihilate-networks 0
  fi

  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage annihilate-networks 1
  fi

  all_inactive_networks=$(get_networks "inactive")
  if [ -z "$all_inactive_networks" ]; then
    printf "\\n%scannot seem to find a single inactive libvirt network on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid network name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_inactive_networks")
      if [ "$answer" == "no" ]; then
        printf "%s'%s' is not an inactive libvirt network%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%sannihilating %s%s\\n" "$green" "$candidate" "$regular"
        virsh net-undefine "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d, skipping %s%s\\n" "$yellow" $virsh_ec "$candidate" "$regular"
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# annihilate_pools_cmd():
#   Removes any trace of one or more inactive storage pools
# ---------------------------------------------------------------------------

annihilate_pools_cmd() {
  if [ "$1" == "help" ]; then
    echo
    show_usage annihilate-pools 0
  fi

  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage annihilate-pools 1
  fi

  all_inactive_pools=$(get_pools "inactive")
  if [ -z "$all_inactive_pools" ]; then
    printf "\\n%scannot seem to find a single inactive pool on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid pool name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_inactive_pools")
      if [ "$answer" == "no" ]; then
        printf "%s'%s' is not an inactive storage pool%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%sannihilating %s%s\\n" "$green" "$candidate" "$regular"
        virsh pool-undefine "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d, skipping %s%s\\n" "$yellow" $virsh_ec "$candidate" "$regular"
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# annihilate_volumes_cmd():
#   Removes any trace of one or more storage volumes
# ---------------------------------------------------------------------------

annihilate_volumes_cmd() {
  if [ "$1" == "help" ]; then
    echo
    show_usage annihilate-volumes 0
  fi

  lowest_num_args=2
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage annihilate-volumes 1
  fi

  param=$(left_part_of "$1" "=")
  the_pool=$(right_part_of "$1" "=")

  if [ "$param" != "--from-pool" ]; then
    printf "\\n%sunknown argument '%s'%s\\n\\n" "$red" "$param" "$regular"
    show_usage annihilate-volumes 1
  fi

  answer=$(is_name_valid "$the_pool")
  if [ "$answer" == "no" ]; then
    printf "%s'%s' is not a valid pool name%s\\n" "$red" "$the_pool" "$regular"
    exit 1
  fi

  all_active_pools=$(get_pools "active")
  if [ -z "$all_active_pools" ]; then
    printf "\\n%scannot seem to find a single active pool on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  answer=$(is_a_member "$the_pool" "$all_active_pools")
  if [ "$answer" == "no" ]; then
    printf "%s'%s' is not an active pool%s\\n" "$red" "$the_pool" "$regular"
    exit 1
  fi

  shift

  all_pool_volumes=$(get_volumes "$the_pool")

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid volume name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_pool_volumes")
      if [ "$answer" == "no" ]; then
        printf "%sthere is no file %s in pool %s%s\\n" "$yellow" "$candidate" "$the_pool" "$regular"
      else
        printf "%sannihilating %s%s\\n" "$green" "$candidate" "$regular"
        virsh vol-delete "$candidate" --pool "$the_pool" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d, skipping %s%s\\n" \
          "$yellow" $virsh_ec "$candidate" "$regular"
        fi
        virsh pool-refresh "$the_pool" > /dev/null 2>&1
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# annihilate_cmd():
#   Removes any trace of inactive VMs,
#   libvirt networks, storage pools, or storage volumes
# ---------------------------------------------------------------------------

annihilate_cmd() {
  entity_type="$1"

  case $entity_type in
  vm|vms)
    shift
    annihilate_vms_cmd "$@"
  ;;
  network|net|networks|nets)
    shift
    annihilate_networks_cmd "$@"
  ;;
  pool|pools)
    shift
    annihilate_pools_cmd "$@"
  ;;
  volume|vol|volumes|vols)
    shift
    annihilate_volumes_cmd "$@"
  ;;
  "")
    printf "\\n%sentity type not specified%s\\n\\n" "$red" "$regular"
    show_usage annihilate 1
  ;;
  *)
    printf "\\n%sinvalid entity type '%s'%s\\n\\n" "$red" "$entity_type" "$regular"
    show_usage annihilate 1
  ;;
  esac
}

# ---------------------------------------------------------------------------
# assimilate_cmd():
#   Copies, if necessary, given files (of type ISO, QCOW2, etc.)
#   into an active storage pool and/or refreshes said pool
# ---------------------------------------------------------------------------

assimilate_cmd() {
  lowest_num_args=2
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage assimilate 1
  fi

  param=$(left_part_of "$1" "=")
  the_pool=$(right_part_of "$1" "=")

  if [ "$param" != "--pool" ]; then
    printf "\\n%sunknown argument '%s'%s\\n\\n" "$red" "$param" "$regular"
    show_usage assimilate 1
  fi

  answer=$(is_name_valid "$the_pool")
  if [ "$answer" == "no" ]; then
    printf "%s'%s' is not a valid pool name%s\\n" "$red" "$the_pool" "$regular"
    exit 1
  fi

  all_active_pools=$(get_pools "active")
  answer=$(is_a_member "$the_pool" "$all_active_pools")
  if [ "$answer" == "no" ]; then
    printf "%s'%s' is not an active pool%s\\n" "$red" "$the_pool" "$regular"
    exit 1
  fi

  virsh pool-refresh "$the_pool" > /dev/null 2>&1
  virsh_ec=$?
  if [ $virsh_ec -ne 0 ]; then
    printf "%sfailed to refresh %s, virsh returned error code %d%s\\n" "$red" "$the_pool" $virsh_ec "$regular"
    exit 1
    fi

  shift

  the_pool_path=$(get_pool_path "$the_pool")

  for candidate; do
    candidate_name=$(basename "$candidate" 2>/dev/null)
    answer=$(is_name_valid "$candidate_name")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid volume name%s\\n" "$yellow" "$candidate" "$regular"
    elif [ ! -f "$candidate" ]; then
      printf "%scannot locate '%s'%s\\n" "$yellow" "$candidate" "$regular"
    else
      candidate_path=$(dirname "$candidate")
      if [ "$candidate_path" == "$the_pool_path" ]; then
        printf "%sfile '%s' is already in the directory of %s%s\\n" "$yellow" "$candidate_name" "$the_pool" "$regular"
      else
        all_pool_volumes=$(get_volumes "$the_pool")
        answer=$(is_a_member "$candidate_name" "$all_pool_volumes")
        if [ "$answer" == "yes" ]; then
          printf "%sthere is already a file named '%s' in pool %s%s\\n" "$yellow" "$candidate_name" "$the_pool" "$regular"
        else
          printf "%scopying %s [%s ==> %s]%s\\n" "$green" "$candidate_name" "$candidate_path" "$the_pool_path" "$regular"
          sudo cp --sparse=always "$candidate" "$the_pool_path"/ > /dev/null 2>&1
          cp_ec=$?
          if [ $cp_ec -ne 0 ]; then
            printf "%sfailed to copy %s from %s to %s, cp returned error code %d%s\\n" \
            "$yellow" "$candidate_name" "$candidate_path" "$the_pool_path" $cp_ec "$regular"
          else
            virsh pool-refresh "$the_pool" > /dev/null 2>&1
            virsh_ec=$?
            if [ $virsh_ec -ne 0 ]; then
              printf "%sfailed to refresh %s, virsh returned error code %d%s\\n" "$yellow" "$the_pool" $virsh_ec "$regular"
            fi
          fi
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# attach_cmd():
#   Attaches a storage volume to an (in)active VM
# ---------------------------------------------------------------------------

attach_cmd() {
  num_args=3
  if [ $# -ne $num_args ]; then
    printf "\\n%sincorrect number of arguments (need exactly %d)%s\\n\\n" "$red" $num_args "$regular"
    show_usage attach 1
  fi

  volume_name=""
  pool_name=""

  for ((argument=1 ; argument <= $((num_args - 1)) ; argument++)); do

    param=$(left_part_of "$1" "=")
    value=$(right_part_of "$1" "=")

    case $param in
      --volume)
        answer=$(is_name_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid volume name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        volume_name=$value
      ;;
      --from-pool)
        answer=$(is_name_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid pool name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_active_pools=$(get_pools "active")
        answer=$(is_a_member "$value" "$all_active_pools")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not an active pool%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_pool_volumes=$(get_volumes "$value")
        answer=$(is_a_member "$volume_name" "$all_pool_volumes")
        if [ "$answer" == "no" ]; then
          printf "%sfile %s is not in pool %s%s\\n" "$red" "$volume_name" "$value" "$regular"
          exit 1
        fi
        pool_name=$value
      ;;
      *)
        printf "\\n%sunknown argument '%s'%s\\n\\n" "$red" "$param" "$regular"
        show_usage attach 1
      ;;
    esac
    shift
  done

  if [ -z "$volume_name" ] || [ -z "$pool_name" ]; then
    printf "\\n%sat least one of the required arguments has not been set%s\\n\\n" "$red" "$regular"
    show_usage attach 1
  fi

  all_VMs=$(virsh list --name --all 2> /dev/null)
  if [ -z "$all_VMs" ]; then
    printf "\\n%scannot seem to find a single (in)active VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  the_vm="$1"
  answer=$(is_name_valid "$the_vm")
  if [ "$answer" == "no" ]; then
    printf "%s'%s' is not a valid VM name%s\\n" "$red" "$the_vm" "$regular"
    exit 1
  fi
  answer=$(is_a_member "$the_vm" "$all_VMs")
  if [ "$answer" == "no" ]; then
    printf "%s'%s' is not a VM%s\\n" "$red" "$the_vm" "$regular"
    exit 1
  fi

  pool_path=$(get_pool_path "$pool_name")
  volume_path="$pool_path"/"$volume_name"

  all_vm_vols=$(get_vm_vols "$the_vm")
  answer=$(is_a_member "$volume_path" "$all_vm_vols")
  if [ "$answer" == "yes" ]; then
    printf "\\n%svolume %s from pool %s is already attached to %s%s\\n\\n" "$yellow" "$volume_name" "$pool_name" "$the_vm" "$regular"
    exit 0
  fi

  virtio_dev=""
  devices_taken=$(in_between "$(virsh dumpxml "$the_vm" | grep "<target dev='")" "<target dev='" "' bus='")
  for letter in {a..z}; do
    device_name=vd"$letter"
    answer=$(is_a_member "$device_name" "$devices_taken")
    if [ "$answer" == "no" ]; then
      virtio_dev="$device_name"
      break
    fi
  done

  if [ -z "$virtio_dev" ]; then
    printf "%sthere seems to be a shortage of VirtIO storage device names for '%s'%s\\n" "$red" "$the_vm" "$regular"
    exit 1
  fi

  printf "%sattaching storage volume %s to %s%s\\n" "$green" "$volume_name" "$the_vm" "$regular"

  virsh attach-disk "$the_vm" "$volume_path" "$virtio_dev" \
    --driver qemu --subdriver qcow2 --targetbus virtio --persistent > /dev/null 2>&1
  virsh_ec=$?
  if [ $virsh_ec -ne 0 ]; then
    printf "%soperation failed, virsh returned error code %d, terminating now%s\\n" "$red" $virsh_ec "$regular"
    exit 2
  fi
}

# ---------------------------------------------------------------------------
# checkservice_cmd():
#   Checks if one or more active VMs are reachable via a specific TCP/port
# ---------------------------------------------------------------------------

checkservice_cmd() {
  lowest_num_args=2
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" "$lowest_num_args" "$regular"
    show_usage check-service 1
  fi

  param=$(left_part_of "$1" "=")
  value=$(right_part_of "$1" "=")

  if [ "$param" != "--port" ]; then
    printf "\\n%sunknown argument '%s'%s\\n\\n" "$red" "$param" "$regular"
    show_usage check-service 1
  fi

  answer=$(is_number_valid "$value")
  if [ "$answer" == "no" ]; then
    printf "%s'%s' is not a positive integer (for TCP port number)%s\\n" "$red" "$value" "$regular"
    exit 1
  fi

  if [ "$value" -lt 1 ] || [ "$value" -gt 65535 ]; then
    printf "%sTCP port number must be between 1 and 65535 inclusive%s\\n" "$red" "$regular"
    exit 1
  fi

  tcp_port=$value

  all_active_VMs=$(virsh list --name 2> /dev/null)
  if [ -z "$all_active_VMs" ]; then
    printf "\\n%scannot seem to find a single active VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  shift

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid VM name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_active_VMs")
      if [ "$answer" == "no" ]; then
        printf "%s%s is not an active VM%s\\n" "$yellow" "$candidate" "$regular"
      else
        candidate_ip=$(get_first_nic_ip "$candidate")
        if [ "$candidate_ip" == "n/a" ]; then
          printf "%s%s does not seem to have any network adapter connected to it%s\\n" "$yellow" "$candidate" "$regular"
        elif [ "$candidate_ip" == "unknown" ]; then
          printf "%scannot get the IP address of %s%s\\n" "$yellow" "$candidate" "$regular"
        else
          nc -z -w 1 "$candidate_ip" "$tcp_port" > /dev/null 2>&1
          netcat_ec=$?
          if [ $netcat_ec -eq 0 ]; then
            printf "%s%s is accepting packets on port %s/TCP%s\\n" "$green" "$candidate" "$tcp_port" "$regular"
          else
            printf "%s%s is not accepting packets on port %s/TCP%s\\n" "$red" "$candidate" "$tcp_port" "$regular"
          fi
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# clone_cmd():
#   Clones a specified template VM into one or more new VMs
# ---------------------------------------------------------------------------

clone_cmd() {
  lowest_num_args=3
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage clone 1
  fi

  template_VM=""
  clone_pool_name=""

  for ((argument=1 ; argument <= $((lowest_num_args - 1)) ; argument++)); do

    param=$(left_part_of "$1" "=")
    value=$(right_part_of "$1" "=")

    case $param in
      --template)
        answer=$(is_name_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid template name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_inactive_VMs=$(virsh list --name --inactive 2> /dev/null)
        answer=$(is_a_member "$value" "$all_inactive_VMs")
        if [ "$answer" == "no" ]; then
          printf "%stemplate should be an existing inactive VM%s\\n" "$red" "$regular"
          exit 1
        fi
        template_VM=$value
      ;;
      --target-pool)
        if [ "$value" != "the_same" ]; then
          answer=$(is_name_valid "$value")
          if [ "$answer" == "no" ]; then
            printf "%s'%s' is not a valid pool name%s\\n" "$red" "$value" "$regular"
            exit 1
          fi
          all_active_pools=$(get_pools "active")
          answer=$(is_a_member "$value" "$all_active_pools")
          if [ "$answer" == "no" ]; then
            printf "%s'%s' is not an active pool%s\\n" "$red" "$value" "$regular"
            exit 1
          fi
        fi
        clone_pool_name=$value
        ;;
      *)
        printf "\\n%sunknown argument '%s'%s\\n\\n" "$red" "$param" "$regular"
        show_usage clone 1
      ;;
    esac
    shift
  done

  if [ -z "$template_VM" ] || [ -z "$clone_pool_name" ]; then
    printf "\\n%sat least one of the required arguments has not been set%s\\n\\n" "$red" "$regular"
    show_usage clone 1
  fi

  block_num=$(get_vm_blk_num "$template_VM")
  if [ $block_num -eq 0 ]; then
    printf "%s%s has no storage volumes attached to it, aborting now%s\\n" "$red" "$template_VM" "$regular"
    exit 1
  elif [ $block_num -gt 1 ]; then
    printf "%s%s has more than one storage volumes attached to it, refusing to clone it%s\\n" "$red" "$template_VM" "$regular"
    exit 1
  fi

  template_pool_name=""
  template_pool_path=""
  template_volume_full_path=$(in_between "$(virsh dumpxml "$template_VM" | grep "<source file='")" "<source file='" "'")
  template_volume_name=$(basename "$template_volume_full_path")

  all_pools=$(get_pools "all")
  for pool in $all_pools; do
    volumes_in_pool=$(get_volumes "$pool")
    answer=$(is_a_member "$template_volume_name" "$volumes_in_pool")
    if [ "$answer" == "yes" ]; then
      template_pool_path=$(dirname "$template_volume_full_path")
      template_pool_name=$pool
      break
    fi
  done

  all_VMs=$(virsh list --name --all 2> /dev/null)

  if [ "$clone_pool_name" == "the_same" ]; then
    clone_pool_path=$template_pool_path
  else
    clone_pool_path=$(get_pool_path "$clone_pool_name")
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid VM name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_VMs")
      if [ "$answer" == "yes" ]; then
        printf "%sthere is already a VM '%s', so I am skipping that one%s\\n" "$yellow" "$candidate" "$regular"
      else
        clone_volume_name="$candidate".qcow2

        printf "%scloning volume %s into %s%s\\n" "$green" "$template_volume_name" "$clone_volume_name" "$regular"

        virsh vol-clone --pool "$template_pool_name" "$template_volume_name" "$clone_volume_name" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d, terminating now%s\\n" "$red" $virsh_ec "$regular"
          exit 2
        fi

        if [ "$clone_pool_path" != "$template_pool_path" ]; then
          printf "%smoving volume %s between pools (%s ==> %s)%s\\n" \
            "$green" "$clone_volume_name" "$template_pool_name" "$clone_pool_name" "$regular"

          sudo mv "$template_pool_path"/"$clone_volume_name" "$clone_pool_path"/
          move_ec=$?
          if [ $move_ec -ne 0 ]; then
            printf "%soperation failed, mv returned error code %d, terminating now%s\\n" "$red" $move_ec "$regular"
            exit 2
          fi

          virsh pool-refresh "$template_pool_name" > /dev/null 2>&1
          virsh pool-refresh "$clone_pool_name" > /dev/null 2>&1
        fi

        printf "%scloning VM %s into %s and attaching volume %s to it%s\\n" \
          "$green" "$template_VM" "$candidate" "$clone_volume_name" "$regular"

        virt-clone -o "$template_VM" -n "$candidate" \
          --preserve-data -f "$clone_pool_path"/"$clone_volume_name" > /dev/null 2>&1
        virt_clone_ec=$?
        if [ $virt_clone_ec -ne 0 ]; then
          printf "%soperation failed, virt-clone returned error code %d, terminating now%s\\n" \
            "$red" $virt_clone_ec "$regular"
          exit 2
        fi

        valid_hostname=$(echo "$candidate" | tr "[:upper:]._" "[:lower:]00")
        valid_hostname=${valid_hostname/%-/0}

        printf "%ssetting '%s' as the hostname for VM %s%s\\n" "$green" "$valid_hostname" "$candidate" "$regular"

        sudo virt-customize -d "$candidate" --hostname "$valid_hostname" > /dev/null 2>&1
        virt_customize_ec=$?
        if [ $virt_customize_ec -ne 0 ]; then
          printf "%svirt-customize returned error code %d%s\\n" "$yellow" $virt_customize_ec "$regular"
        fi

        printf "%sdeleting SSH host keys from VM %s%s\\n" "$green" "$candidate" "$regular"

        sudo virt-customize -d "$candidate" \
          --delete /etc/ssh/ssh_host_dsa_key \
          --delete /etc/ssh/ssh_host_dsa_key.pub \
          --delete /etc/ssh/ssh_host_ecdsa_key \
          --delete /etc/ssh/ssh_host_ecdsa_key.pub \
          --delete /etc/ssh/ssh_host_ed25519_key \
          --delete /etc/ssh/ssh_host_ed25519_key.pub \
          --delete /etc/ssh/ssh_host_key \
          --delete /etc/ssh/ssh_host_key.pub \
          --delete /etc/ssh/ssh_host_rsa_key \
          --delete /etc/ssh/ssh_host_rsa_key.pub \
          > /dev/null 2>&1
        virt_customize_ec=$?
        if [ $virt_customize_ec -ne 0 ]; then
          printf "%svirt-customize returned error code %d%s\\n" "$yellow" $virt_customize_ec "$regular"
        fi
        echo
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# create_network_cmd():
#   Instantiates a new libvirt network
# ---------------------------------------------------------------------------

create_network_cmd() {
  net_type=""
  net_name=""
  domain_name=""
  router_addr=""
  netmask_addr=""
  dhcp_srv=""
  from_addr=""
  to_addr=""

  for argument; do

    param=$(left_part_of "$argument" "=")
    value=$(right_part_of "$argument" "=")

    case $param in
      --type)
        if [ "$value" != "nated" ] && [ "$value" != "isolated" ]; then
          printf "%s'%s' is not a valid network type%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        net_type=$value
      ;;
      --name)
        answer=$(is_name_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid network name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_active_networks=$(get_networks "active")
        answer=$(is_a_member "$value" "$all_active_networks")
        if [ "$answer" == "yes" ]; then
          printf "%sactive network '%s' already exists%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        net_name=$value
      ;;
      --domain)
        first_char_test=$(echo "${value:0:1}" | tr -d "[:alnum:]")
        if [ -n "$first_char_test" ]; then
          printf "%s'%s' is not a valid domain name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        domain_pattern='(?=^.{5,254}$)(^(?:(?!\d+\.)[a-zA-Z0-9_\-]{1,63}\.?)+(?:[a-zA-Z]{2,})$)'
        test_result=$(echo "$value" | grep -P "$domain_pattern")
        if [ -z "$test_result" ]; then
          printf "%s'%s' is not a valid domain name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_active_networks=$(get_networks "active")
        for each_net in $all_active_networks; do
          domain_name=$(in_between "$(virsh net-dumpxml "$each_net" | grep "<domain name='")" "<domain name='" "'")
          if [ "$value" == "$domain_name" ]; then
            printf "%sdomain %s is already used in active network %s%s\\n" "$red" "$value" "$each_net" "$regular"
            exit 1
          fi
        done
        domain_name=$value
      ;;
      --router)
        answer=$(is_ipv4_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid router IPv4 address%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_active_networks=$(get_networks "active")
        for each_net in $all_active_networks; do
          router_addr=$(in_between "$(virsh net-dumpxml "$each_net" | grep "<ip address='")" "<ip address='" "'")
          if [ "$value" == "$router_addr" ]; then
            printf "%srouter address %s is already used in active network %s%s\\n" "$red" "$value" "$each_net" "$regular"
            exit 1
          fi
        done
        router_addr=$value
      ;;
      --netmask)
        answer=$(is_ipv4_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid netmask IPv4 address%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        netmask_addr=$value
      ;;
      --dhcp)
        if [ "$value" != "on" ] && [ "$value" != "off" ]; then
          printf "%svalue for --dhcp should be either on or off%s\\n" "$red" "$regular"
          exit 1
        fi
        dhcp_srv=$value
      ;;
      --from)
        answer=$(is_ipv4_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid IPv4 address for the '--from' parameter%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        from_addr=$value
      ;;
      --to)
        answer=$(is_ipv4_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid IPv4 address for the '--to' parameter%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        to_addr=$value
      ;;
      help)
        echo
        show_usage create-network 0
      ;;
      *)
        printf "\\n%sunknown argument '%s'%s\\n\\n" "$red" "$param" "$regular"
        show_usage create-network 1
      ;;
    esac
  done

  if [ "$net_type" == "isolated" ]; then
    if [ -z "$net_name" ] || [ -z "$domain_name" ]; then
      printf "\\n%snetwork name and/or domain name has not been set for isolated network%s\\n\\n" "$red" "$regular"
      show_usage create-network 1
    fi
  else
    if [ -z "$net_name" ] || [ -z "$domain_name" ] || [ -z "$router_addr" ] || [ -z "$netmask_addr" ] || [ -z "$dhcp_srv" ]; then
      printf "\\n%sat least one of the required arguments has not been set for NATed network%s\\n\\n" "$red" "$regular"
      show_usage create-network 1
    fi
    if [ "$dhcp_srv" == "on" ] && ([ -z "$from_addr" ] || [ -z "$to_addr" ]); then
      printf "\\n%sIP range for dynamic address allocation has not been defined%s\\n\\n" "$red" "$regular"
      show_usage create-network 1
    fi
  fi

  max_bridge_devs=25
  all_networks=$(get_networks "all")
  how_many=$(echo "$all_networks" | wc -w)

    if [ "$how_many" -ge "$max_bridge_devs" ]; then
    printf "%sthere are already %d libvirt (in)active " "$red" $max_bridge_devs
    printf "networks available, refusing to create another one%s\\n" "$regular"
        exit 1
    fi

  # in openSUSE, default.xml is included in package libvirt-daemon-config-network
  default_net_xml="/usr/share/libvirt/networks/default.xml"

  if [ ! -f "$default_net_xml" ]; then
    default_net_xml="/tmp/default.xml.for.NATed.libvirt.networks-qboxes"
    virsh net-dumpxml default > "$default_net_xml" 2> /dev/null
    virsh_ec=$?
    if [ $virsh_ec -ne 0 ]; then
      default_net_xml=""
    fi
  fi

  if [ -z "$default_net_xml" ]; then
    printf "%scannot find template file default.xml, nor libvirt network 'default'%s\\n" "$red" "$regular"
    exit 1
  fi

  bridge_dev=""
  names_taken=""

  prefix=$(echo "$(in_between "$(grep "<bridge name=" "$default_net_xml")" "<bridge name=" "/")" | awk '{ print $1 }' | tr -d "0-9\"\\'")

  for each_net in $all_networks; do
    bridge_name=$(in_between "$(virsh net-dumpxml "$each_net" | grep "<bridge name='")" "<bridge name='" "'")
    names_taken=${names_taken}${bridge_name}" "
  done

  for ((digit=0 ; digit < max_bridge_devs ; digit++)); do
    candidate="$prefix""$digit"
    answer=$(is_a_member "$candidate" "$names_taken")
    if [ "$answer" == "no" ]; then
      bridge_dev="$candidate"
      break
    fi
  done

  if [ "$net_type" == "isolated" ]; then
    temp_net_xml="$(create_xml_net_isolated "$net_name" \
      "$bridge_dev" "$domain_name")"
  elif [ "$dhcp_srv" == "off" ]; then
    temp_net_xml="$(create_xml_net_nat_no_dhcp "$net_name" \
      "$bridge_dev" "$domain_name" "$router_addr" "$netmask_addr")"
  else
    temp_net_xml="$(create_xml_net_nat_dhcp "$net_name" \
      "$bridge_dev" "$domain_name" "$router_addr" "$netmask_addr" "$from_addr" "$to_addr")"
  fi

  virsh net-define "$temp_net_xml" > /dev/null 2>&1
  virsh_ec=$?

  rm "$temp_net_xml"

  if [ $virsh_ec -ne 0 ]; then
    printf "%sfailed to define %s, virsh returned error code %d, terminating now%s\\n" "$red" "$net_name" $virsh_ec "$regular"
    exit 2
  fi

  virsh net-start "$net_name" > /dev/null 2>&1
  virsh_ec=$?
  if [ $virsh_ec -ne 0 ]; then
    printf "%sfailed to start %s, virsh returned error code %d%s\\n" "$yellow" "$net_name" $virsh_ec "$regular"
  fi

  virsh net-autostart "$net_name" > /dev/null 2>&1
  virsh_ec=$?
  if [ $virsh_ec -ne 0 ]; then
    printf "%sfailed to mark %s as 'autostart', virsh returned error code %d%s\\n" "$yellow" "$net_name" $virsh_ec "$regular"
  fi

  printf "%snetwork %s successfully created%s\\n" "$green" "$net_name" "$regular"
}

# ---------------------------------------------------------------------------
# create_pool_cmd()
#   Instantiates a new storage pool
# ---------------------------------------------------------------------------

create_pool_cmd() {
  pool_name=""
  local_path=""

  for argument; do

    param=$(left_part_of "$argument" "=")
    value=$(right_part_of "$argument" "=")

    case $param in
      --name)
        answer=$(is_name_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid pool name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_pools=$(get_pools "all")
        answer=$(is_a_member "$value" "$all_pools")
        if [ "$answer" == "yes" ]; then
          printf "%spool '%s' already exists%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        pool_name=$value
      ;;
      --path)
        if [ -z "$value" ]; then
          printf "%spool path not specified%s\\n" "$red" "$regular"
          exit 1
        fi
        if [ ! -d "$value" ]; then
          printf "%spath '%s' does not exist%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_pools=$(get_pools "all")
        for each_pool in $all_pools; do
          local_path=$(get_pool_path "$each_pool")
          if [ "$value" == "$local_path" ]; then
            printf "%spool %s is already defined under %s%s\\n" "$red" "$each_pool" "$value" "$regular"
            exit 1
          fi
        done
        local_path=$value
      ;;
      help)
        echo
        show_usage create-pool 0
      ;;
      *)
        printf "\\n%sunknown argument '%s'%s\\n\\n" "$red" "$param" "$regular"
        show_usage create-pool 1
      ;;
    esac
  done

  if [ -z "$pool_name" ] || [ -z "$local_path" ]; then
    printf "\\n%sat least one of the required arguments has not been set%s\\n\\n" "$red" "$regular"
    show_usage create-pool 1
  fi

  virsh pool-define-as "$pool_name" dir - - - - "$local_path" > /dev/null 2>&1
  virsh_ec=$?
  if [ $virsh_ec -ne 0 ]; then
    printf "%sfailed to define %s, virsh returned error code %d, terminating now%s\\n" "$red" "$pool_name" $virsh_ec "$regular"
    exit 2
  fi

  virsh pool-start "$pool_name" > /dev/null 2>&1
  virsh_ec=$?
  if [ $virsh_ec -ne 0 ]; then
    printf "%sfailed to start %s, virsh returned error code %d%s\\n" "$yellow" "$pool_name" $virsh_ec "$regular"
  fi

  virsh pool-autostart "$pool_name" > /dev/null 2>&1
  virsh_ec=$?
  if [ $virsh_ec -ne 0 ]; then
    printf "%sfailed to mark %s as 'autostart', virsh returned error code %d%s\\n" "$yellow" "$pool_name" $virsh_ec "$regular"
  fi

  printf "%spool %s successfully created%s\\n" "$green" "$pool_name" "$regular"
}

# ---------------------------------------------------------------------------
# create_volume_cmd()
#   Creates a new volume within given active storage pool
# ---------------------------------------------------------------------------

create_volume_cmd() {
  volume_name=""
  volume_size=""
  pool_name=""

  for argument; do

    param=$(left_part_of "$argument" "=")
    value=$(right_part_of "$argument" "=")

    case $param in
      --name)
        answer=$(is_name_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid volume name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        volume_name=$value
      ;;
      --pool)
        answer=$(is_name_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid pool name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_active_pools=$(get_pools "active")
        answer=$(is_a_member "$value" "$all_active_pools")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not an active pool%s\\n" "$yellow" "$value" "$regular"
          exit 1
        fi
        all_pool_volumes=$(get_volumes "$value")
        answer=$(is_a_member "$volume_name" "$all_pool_volumes")
        if [ "$answer" == "yes" ]; then
          printf "%sfile %s already exists in pool %s%s\\n" "$red" "$volume_name" "$value" "$regular"
          exit 1
        fi
        pool_name=$value
      ;;
      --size)
        answer=$(is_number_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a positive integer (for volume size)%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        volume_size_min=32
        volume_size_max=8192
        answer=$(is_size_valid "$value" "$volume_size_min" "$volume_size_max")
        if [ "$answer" == "no" ]; then
          printf "%svolume size must be between %d and %d GiB inclusive, and an integer multiple of %d%s\\n" \
          "$red" $volume_size_min $volume_size_max $volume_size_min "$regular"
          exit 1
        fi
        volume_size=$value
      ;;
      help)
        echo
        show_usage create-volume 0
      ;;
      *)
        printf "\\n%sunknown argument '%s'%s\\n\\n" "$red" "$param" "$regular"
        show_usage create-volume 1
      ;;
    esac
    shift
  done

  if [ -z "$volume_name" ] || [ -z "$volume_size" ] || [ -z "$pool_name" ]; then
    printf "\\n%sat least one of the required arguments has not been set%s\\n\\n" "$red" "$regular"
    show_usage create-volume 1
  fi

  printf "%screating sparse file %s with maximum size %sGiB, in pool %s%s\\n" "$green" "$volume_name" "$volume_size" "$pool_name" "$regular"

  virsh vol-create-as "$pool_name" --name "$volume_name" --capacity "$volume_size"G --format qcow2 > /dev/null 2>&1
  virsh_ec=$?
  if [ $virsh_ec -ne 0 ]; then
    printf "%soperation failed, virsh returned error code %d, terminating now%s\\n" "$red" $virsh_ec "$regular"
    exit 2
  fi
}

# ---------------------------------------------------------------------------
# create_cmd():
#   Creates a new libvirt network,
#   a new storage pool, or a new storage volume
# ---------------------------------------------------------------------------

create_cmd() {
  entity_type="$1"

  case $entity_type in
  network|net)
    shift
    create_network_cmd "$@"
  ;;
  pool)
    shift
    create_pool_cmd "$@"
  ;;
  volume|vol)
    shift
    create_volume_cmd "$@"
  ;;
  "")
    printf "\\n%sentity type not specified%s\\n\\n" "$red" "$regular"
    show_usage create 1
  ;;
  *)
    printf "\\n%sinvalid entity type '%s'%s\\n\\n" "$red" "$entity_type" "$regular"
    show_usage create 1
  ;;
  esac
}

# ---------------------------------------------------------------------------
# deactivate_vms_cmd():
#   Gracefully shuts down one or more active VMs
# ---------------------------------------------------------------------------

deactivate_vms_cmd() {
  if [ "$1" == "help" ]; then
    echo
    show_usage deactivate-vms 0
  fi

  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" \
      "$red" $lowest_num_args "$regular"
    show_usage deactivate-vms 1
  fi

  all_active_VMs=$(virsh list --name 2> /dev/null)
  if [ -z "$all_active_VMs" ]; then
    printf "\\n%scannot seem to find a single active VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid VM name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_active_VMs")
      if [ "$answer" == "no" ]; then
        printf "%s%s is not an active VM%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%sshutting down %s%s\\n" "$green" "$candidate" "$regular"
        virsh shutdown "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d%s\\n" "$yellow" $virsh_ec "$regular"
        fi
        sleep 1
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# deactivate_networks_cmd():
#   Deactivates one or more active libvirt networks
# ---------------------------------------------------------------------------

deactivate_networks_cmd()
{
  if [ "$1" == "help" ]; then
    echo
    show_usage deactivate-networks 0
  fi

  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage deactivate-networks 1
  fi

  all_active_networks=$(get_networks "active")
  if [ -z "$all_active_networks" ]; then
    printf "\\n%scannot seem to find a single active network on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid network name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_active_networks")
      if [ "$answer" == "no" ]; then
        printf "%s'%s' is not an active network%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%sdeactivating %s%s\\n" "$green" "$candidate" "$regular"
        virsh net-destroy "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d%s\\n" "$yellow" $virsh_ec "$regular"
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# deactivate_pools_cmd():
#   Deactivates one or more active storage pools
# ---------------------------------------------------------------------------

deactivate_pools_cmd()
{
  if [ "$1" == "help" ]; then
    echo
    show_usage deactivate-pools 0
  fi

  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage deactivate-pools 1
  fi

  all_active_pools=$(get_pools "active")
  if [ -z "$all_active_pools" ]; then
    printf "\\n%scannot seem to find a single active pool on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid pool name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_active_pools")
      if [ "$answer" == "no" ]; then
        printf "%s'%s' is not an active pool%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%sdeactivating %s%s\\n" "$green" "$candidate" "$regular"
        virsh pool-destroy "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d%s\\n" "$yellow" $virsh_ec "$regular"
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# deactivate_cmd():
#   Gracefully shuts down active VMs,
#   deactivates active libvirt networks or storage pools
# ---------------------------------------------------------------------------

deactivate_cmd() {
  entity_type="$1"

  case $entity_type in
  vm|vms)
    shift
    deactivate_vms_cmd "$@"
  ;;
  network|net|networks|nets)
    shift
    deactivate_networks_cmd "$@"
  ;;
  pool|pools)
    shift
    deactivate_pools_cmd "$@"
  ;;
  "")
    printf "\\n%sentity type not specified%s\\n\\n" "$red" "$regular"
    show_usage deactivate 1
  ;;
  *)
    printf "\\n%sinvalid entity type '%s'%s\\n\\n" "$red" "$entity_type" "$regular"
    show_usage deactivate 1
  ;;
  esac
}

# ---------------------------------------------------------------------------
# define_cmd():
#   Defines a new VM, sans guest OS, according to specifications
# ---------------------------------------------------------------------------

define_cmd() {
  num_args=8
  if [ $# -lt $num_args ]; then
    printf "\\n%sincorrect number of arguments (need exactly %d)%s\\n\\n" "$red" $num_args "$regular"
    show_usage define 1
  fi

  memory_size=""
  cpu_cores=""
  volume_name=""
  pool_name=""
  network_spec=""
  mac_addr=""
  os_variant=""

  for ((argument=1 ; argument <= $((num_args - 1)) ; argument++)); do

    param=$(left_part_of "$1" "=")
    value=$(right_part_of "$1" "=")

    case $param in
      --ram)
        answer=$(is_number_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a positive integer (for RAM size)%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        memory_size_min=32
        memory_size_max=16384
        answer=$(is_size_valid "$value" "$memory_size_min" "$memory_size_max")
        if [ "$answer" == "no" ]; then
          printf "%smemory size must be between %d and %d MiB inclusive, and an integer multiple of %d%s\\n" \
          "$red" $memory_size_min $memory_size_max $memory_size_min "$regular"
          exit 1
        fi
        memory_size=$value
      ;;
      --cores)
        answer=$(is_number_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a positive integer (for core count)%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        cpu_cores_max=$(right_part_of "$(virsh nodeinfo | grep "CPU(s):")" ":")
        if [ "$value" -lt 1 ] || [ "$value" -gt "$cpu_cores_max" ]; then
          printf "%snumber of CPU cores should be between 1 and %d inclusive%s\\n" "$red" "$cpu_cores_max" "$regular"
          exit 1
        fi
        cpu_cores=$value
      ;;
      --osdisk)
        answer=$(is_name_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid volume name (for OS disk)%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        volume_name=$value
      ;;
      --from-pool)
        answer=$(is_name_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid pool name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_active_pools=$(get_pools "active")
        answer=$(is_a_member "$value" "$all_active_pools")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not an active pool%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_pool_volumes=$(get_volumes "$value")
        answer=$(is_a_member "$volume_name" "$all_pool_volumes")
        if [ "$answer" == "no" ]; then
          printf "%sfile %s is not in pool %s%s\\n" "$red" "$volume_name" "$value" "$regular"
          exit 1
        fi
        pool_name=$value
      ;;
      --network)
        if [ "$value" == "host_bridge" ]; then
          bridge_gw_dev=$(get_bridge_gw_dev)
          if [ "$bridge_gw_dev" == "n/a" ]; then
            printf "%scannot seem to find a bridge gateway device on this host%s\\n" "$red" "$regular"
            exit 1
          fi
          network_spec="bridge=""$bridge_gw_dev"
        else
          answer=$(is_name_valid "$value")
          if [ "$answer" == "no" ]; then
            printf "%s'%s' is not a valid network name%s\\n" "$red" "$value" "$regular"
            exit 1
          fi
          all_active_networks=$(get_networks "active")
          answer=$(is_a_member "$value" "$all_active_networks")
          if [ "$answer" == "no" ]; then
            printf "%scannot seem to find active network '%s'%s\\n" "$red" "$value" "$regular"
            exit 1
          fi
          network_spec="network=""$value"
        fi
      ;;
      --mac)
        if [ "$value" != "auto" ]; then
          answer=$(is_mac_valid "$value")
          if [ "$answer" == "no" ]; then
            printf "%s'%s' is not a valid MAC address%s\\n" "$red" "$value" "$regular"
            exit 1
          fi
        fi
        mac_addr=$value
      ;;
      --guest-os)
        answer=$(is_name_valid "$value")
        if [ "$answer" == "no" ]; then
          printf "%s'%s' is not a valid OS variant name%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        all_os_variants=$(osinfo-query os -f short-id 2> /dev/null)
        answer=$(is_a_member "$value" "$all_os_variants")
        if [ "$answer" == "no" ]; then
          printf "%sunknown OS variant '%s'%s\\n" "$red" "$value" "$regular"
          exit 1
        fi
        os_variant=$value
      ;;
      *)
        printf "\\n%sunknown argument '%s'%s\\n\\n" "$red" "$param" "$regular"
        show_usage define 1
      ;;
    esac
    shift
  done

  if [ -z "$memory_size" ] || [ -z "$cpu_cores" ] \
    || [ -z "$volume_name" ] || [ -z "$pool_name" ] \
    || [ -z "$network_spec" ] || [ -z "$mac_addr" ] || [ -z "$os_variant" ]; then
    printf "\\n%sat least one of the required arguments has not been set%s\\n\\n" "$red" "$regular"
    show_usage define 1
  fi

  the_vm="$1"
  answer=$(is_name_valid "$the_vm")
  if [ "$answer" == "no" ]; then
    printf "%s'%s' is not a valid VM name%s\\n" "$red" "$the_vm" "$regular"
    exit 1
  fi

  all_VMs=$(virsh list --name --all 2> /dev/null)
  answer=$(is_a_member "$the_vm" "$all_VMs")
  if [ "$answer" == "yes" ]; then
    printf "%sthere is already a VM '%s', and I am not touching it%s\\n" "$red" "$candidate" "$regular"
    exit 1
  fi

  xml_path="/tmp/""$(get_random_alphanum)".xml
  pool_path=$(get_pool_path "$pool_name")
  volume_path="$pool_path"/"$volume_name"

  for each_vm in $all_VMs; do
    all_vm_vols=$(get_vm_vols "$each_vm")
    answer=$(is_a_member "$volume_path" "$all_vm_vols")
    if [ "$answer" == "yes" ]; then
      printf "%sstorage volume %s is already connected to VM %s%s\\n" "$red" "$volume_name" "$each_vm" "$regular"
      exit 1
    fi
  done

  printf "%scoming up with a detailed XML description of %s%s\\n" "$green" "$the_vm" "$regular"

  if [ "$mac_addr" == "auto" ]; then
    mac_spec=""
  else
    canonical_mac=$(get_canonical_mac "$mac_addr" "52:54:00")
    mac_spec=",mac=""$canonical_mac"
  fi

  virt-install --name "$the_vm" --os-variant "$os_variant" \
    --memory "$memory_size" --cpu host --vcpus="$cpu_cores" \
    --network "$network_spec",model=virtio"$mac_spec" --disk "$volume_path",bus=virtio \
    --boot network,hd --print-xml 1 > "$xml_path" 2> /dev/null

  virt_install_ec=$?
  if [ $virt_install_ec -ne 0 ]; then
    printf "%soperation failed, virt-install returned error code %d, terminating now%s\\n" \
      "$red" $virt_install_ec "$regular"
    rm -f "$xml_path"
    exit 2
  fi

  printf "%sretracting sound card & tablet input devices from XML description%s\\n" "$green" "$regular"

  sed -i /'<sound model'/d "$xml_path"
  sed -i /'<input type="tablet'/d "$xml_path"

  printf "%sdefining %s%s\\n\\n" "$green" "$the_vm" "$regular"

  virsh define "$xml_path" --validate > /dev/null 2>&1

  virsh_ec=$?
  if [ $virsh_ec -ne 0 ]; then
    printf "%soperation failed, virsh returned error code %d, terminating now%s\\n" "$red" $virsh_ec "$regular"
    rm -f "$xml_path"
    exit 2
  fi
  rm -f "$xml_path"
}

# ---------------------------------------------------------------------------
# getmac_cmd():
#   Display the MAC address of the first network adapter of one or more VMs
# ---------------------------------------------------------------------------

getmac_cmd() {
  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage getmac 1
  fi

  all_VMs=$(virsh list --name --all 2> /dev/null)
  if [ -z "$all_VMs" ]; then
    printf "\\n%scannot seem to find a single (in)active VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid VM name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_VMs")
      if [ "$answer" == "no" ]; then
        printf "%scannot seem to find VM '%s'%s\\n" "$yellow" "$candidate" "$regular"
      else
        mac_addr=$(get_first_nic_mac "$candidate")
        printf "%s%s looks like %s in the local network%s\\n" "$green" "$candidate" "$mac_addr" "$regular"
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# list_vms_cmd():
#   Presents all available VMs
# ---------------------------------------------------------------------------

list_vms_cmd() {
  all_VMs=$(virsh list --name --all 2> /dev/null)
  if [ -z "$all_VMs" ]; then
    printf "\\n%scannot seem to find a single (in)active VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  temp_file_name="/tmp/""$(get_random_alphanum)".lst

  echo "Name State CPU(s) RAM[MiB] NIC(s) PrimNet PrimAdaptIP" >> "$temp_file_name"
  echo "---- ----- ------ -------- ------ ------- -----------" >> "$temp_file_name"

  for name in $all_VMs; do
    state=$(echo "$(right_part_of "$(virsh dominfo "$name" | grep State)" ":")" | awk '{ print $1 }')
    if [ "$state" == "running" ]; then
      state="active"
    else
      state="inactive"
    fi

    CPUs=$(echo "$(right_part_of "$(virsh dominfo "$name" | grep CPU\(s\))" ":")" | awk '{ print $1 }')
    ram_size=$(in_between "$(virsh dominfo "$name" | grep "Max memory")" ":" " ")
    ram_size_mb=$(( ram_size / 1024 ))

    first_nic_net="n/a"
    first_nic_ip="n/a"

    nated_net="<source network='"
    bridged_net="<interface type='bridge'"
    network_adapters=$(virsh dumpxml "$name" | grep -e "$nated_net" -e "$bridged_net" -c)

    if [ "$network_adapters" -gt 0 ]; then
      first_nic_net=$(get_first_nic_net "$name")
      if [ "$state" != "inactive" ]; then
        first_nic_ip=$(get_first_nic_ip "$name")
      fi
    fi

    echo "$name" "$state" "$CPUs" "$ram_size_mb" "$network_adapters" \
      "$first_nic_net" "$first_nic_ip" >> "$temp_file_name"
  done

  echo
  column -t "$temp_file_name"
  echo

  rm -f "$temp_file_name"
}

# ---------------------------------------------------------------------------
# list_networks_cmd():
#   Presents all available libvirt networks
# ---------------------------------------------------------------------------

list_networks_cmd() {
  all_networks=$(get_networks "all")
  if [ -z "$all_networks" ]; then
    printf "\\n%scannot seem to find a single (in)active libvirt network on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  temp_file_name="/tmp/""$(get_random_alphanum)".lst

  echo "Name State Mode Domain MACaddr Router/DNSaddr DHCP fromIPaddr toIPaddr Clients" >> "$temp_file_name"
  echo "---- ----- ---- ------ ------- -------------- ---- ---------- -------- -------" >> "$temp_file_name"

  all_VMs=$(virsh list --name --all 2> /dev/null)

  for name in $all_networks; do
    state=$(echo "$(right_part_of "$(virsh net-info "$name" | grep Active)" ":")" | awk '{ print $1 }')
    if [ "$state" == "yes" ]; then
      state="active"
    else
      state="inactive"
    fi

    ip_addr="n/a"
    ip_begin="n/a"
    ip_end="n/a"
    dhcp_server="n/a"

    mode=$(in_between "$(virsh net-dumpxml "$name" | grep "mode='")" "mode='" "'")
    if [ -z "$mode" ]; then
      mode="isolated"
    else
      ip_addr=$(in_between "$(virsh net-dumpxml "$name" | grep "<ip address='")" "<ip address='" "'")
      dhcp_server=$(virsh net-dumpxml "$name" | grep '<dhcp>')
      if [ -z "$dhcp_server" ]; then
        dhcp_server="off"
      else
        dhcp_server="on"
        ip_begin=$(in_between "$(virsh net-dumpxml "$name" | grep "<range start='")" "<range start='" "'")
        ip_end=$(in_between "$(virsh net-dumpxml "$name" | grep "<range start='")" "' end='" "'")
      fi
    fi

    domain_name=$(in_between "$(virsh net-dumpxml "$name" | grep "<domain name='")" "<domain name='" "'")
    if [ -z "$domain_name" ]; then
      domain_name="n/a"
    fi

    mac_addr=$(in_between "$(virsh net-dumpxml "$name" | grep "<mac address='")" "<mac address='" "'")
    if [ -z "$mac_addr" ]; then
      mac_addr="n/a"
    fi

    net_clients=0
    if [ -n "$all_VMs" ]; then
      for guest in $all_VMs; do
        how_many=$(virsh dumpxml "$guest" | grep -c "<source network='""$name""'/>")
        if [ "$how_many" -gt 0 ]; then
          (( net_clients += 1 ))
        fi
      done
    fi

    echo "$name" "$state" "$mode" "$domain_name" "$mac_addr" "$ip_addr" \
      "$dhcp_server" "$ip_begin" "$ip_end" "$net_clients" >> "$temp_file_name"
  done

  echo
  column -t "$temp_file_name"
  echo

  rm -f "$temp_file_name"
}

# ---------------------------------------------------------------------------
# list_pools_cmd():
#   Presents all available storage pools
# ---------------------------------------------------------------------------

list_pools_cmd() {
  all_pools=$(get_pools "all")
  if [ -z "$all_pools" ]; then
    printf "\\n%scannot seem to find a single (in)active pool on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  temp_file_name="/tmp/""$(get_random_alphanum)".lst

  echo "Name State Capacity Allocation Available PoolDirPath Volumes" >> "$temp_file_name"
  echo "---- ----- -------- ---------- --------- ----------- -------" >> "$temp_file_name"

  for name in $all_pools; do
    state=$(echo "$(right_part_of "$(virsh pool-info "$name" | grep "State:")" "State:")" | awk '{ print $1 }')
    if [ "$state" == "running" ]; then
      state="active"
      capacity=$(echo "$(right_part_of "$(virsh pool-info "$name" | grep "Capacity")" "Capacity:")" | tr -d " ") 
      allocation=$(echo "$(right_part_of "$(virsh pool-info "$name" | grep "Allocation")" "Allocation:")" | tr -d " ")
      available=$(echo "$(right_part_of "$(virsh pool-info "$name" | grep "Available")" "Available:")" | tr -d " ")
      volumes=$(echo "$(get_volumes "$name")" | wc -w)
    else
      state="inactive"
      capacity="n/a"
      allocation="n/a"
      available="n/a"
      volumes="n/a"
    fi

    path2pool_dir=$(get_pool_path "$name")

    echo "$name" "$state" "$capacity" "$allocation" "$available" "$path2pool_dir" "$volumes" >> "$temp_file_name"
  done

  echo
  column -t "$temp_file_name"
  echo

  rm -f "$temp_file_name"
}

# ---------------------------------------------------------------------------
# list_volumes_cmd():
#   Presents all available storage volumes
# ---------------------------------------------------------------------------

list_volumes_cmd() {
  all_active_pools=$(get_pools "active")
  if [ -z "$all_active_pools" ]; then
    printf "\\n%scannot seem to find a single (in)active pool on this host, " "$yellow"
    printf "so I am assuming there are no volumes either%s\\n\\n" "$regular"
    exit 0
  fi

  temp_file_name="/tmp/""$(get_random_alphanum)".lst

  echo "Volume Capacity Allocation Pool" >> "$temp_file_name"
  echo "------ -------- ---------- ----" >> "$temp_file_name"

  for pool in $all_active_pools; do
    virsh pool-refresh "$pool" > /dev/null 2>&1
    volumes_in_pool=$(get_volumes "$pool")
    for volume in $volumes_in_pool; do
      capacity=$(echo "$(right_part_of "$(virsh vol-info "$volume" "$pool" | grep "Capacity:")" "Capacity:")" | tr -d " ")
      allocation=$(echo "$(right_part_of "$(virsh vol-info "$volume" "$pool" | grep "Allocation:")" "Allocation:")" | tr -d " ")
      echo "$volume" "$capacity" "$allocation" "$pool" >> "$temp_file_name"
    done
  done

  echo
  column -t "$temp_file_name"
  echo

  rm -f "$temp_file_name"
}

# ---------------------------------------------------------------------------
# list_cmd():
#   Presents all available (in)active VMs,
#   libvirt networks, storage pools, or storage volumes
# ---------------------------------------------------------------------------

list_cmd() {
  entity_type="$1"

  case $entity_type in
  vm|vms)
    shift
    list_vms_cmd "$@"
  ;;
  network|net|networks|nets)
    shift
    list_networks_cmd "$@"
  ;;
  pool|pools)
    shift
    list_pools_cmd "$@"
  ;;
  volume|vol|volumes|vols)
    shift
    list_volumes_cmd "$@"
  ;;
  "")
    printf "\\n%sentity type not specified%s\\n\\n" "$red" "$regular"
    show_usage list 1
  ;;
  *)
    printf "\\n%sinvalid entity type '%s'%s\\n\\n" "$red" "$entity_type" "$regular"
    show_usage list 1
  ;;
  esac
}

# ---------------------------------------------------------------------------
# ping_cmd():
#   Sends a specified number of ICMP packets to one or more active VMs
# ---------------------------------------------------------------------------

ping_cmd() {
  lowest_num_args=2
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage ping 1
  fi

  param=$(left_part_of "$1" "=")
  n_packets=$(right_part_of "$1" "=")

  if [ "$param" != "--count" ]; then
    printf "\\n%sunknown argument '%s'%s\\n\\n" "$red" "$param" "$regular"
    show_usage ping 1
  fi

  answer=$(is_number_valid "$n_packets")
  if [ "$answer" == "no" ]; then
    printf "%s'%s' is not a positive integer (for packet count)%s\\n" "$red" "$value" "$regular"
    exit 1
  fi

  count_min=1
  count_max=64

  if [ "$n_packets" -lt "$count_min" ] || [ "$n_packets" -gt "$count_max" ]; then
    printf "%spacket count should be between %d and %d inclusive%s\\n" "$red" $count_min $count_max "$regular"
    exit 1
  fi

  all_active_VMs=$(virsh list --name 2> /dev/null)
  if [ -z "$all_active_VMs" ]; then
    printf "\\n%scannot seem to find a single active VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  shift

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid VM name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_active_VMs")
      if [ "$answer" == "no" ]; then
        printf "%s%s is not an active VM%s\\n" "$yellow" "$candidate" "$regular"
      else
        candidate_ip=$(get_first_nic_ip "$candidate")
        if [ "$candidate_ip" == "n/a" ]; then
          printf "%s%s does not seem to have any network adapter connected to it%s\\n" "$yellow" "$candidate" "$regular"  
        elif [ "$candidate_ip" == "unknown" ]; then
          printf "%scannot get the IP address of %s%s\\n" "$yellow" "$candidate" "$regular"
        else
          printf "\\n%sattempting to ping %s%s\\n" "$green" "$candidate" "$regular"
          /bin/ping -c "$n_packets" "$candidate_ip"
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# powcycle_cmd():
#   Cold-restarts one or more active VMs
# ---------------------------------------------------------------------------

powcycle_cmd() {
  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" \
      "$red" $lowest_num_args "$regular"
    show_usage powcycle 1
  fi

  all_active_VMs=$(virsh list --name 2> /dev/null)
  if [ -z "$all_active_VMs" ]; then
    printf "\\n%scannot seem to find a single active VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid VM name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_active_VMs")
      if [ "$answer" == "no" ]; then
        printf "%s%s is not an active VM%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%scold-restarting %s%s\\n" "$green" "$candidate" "$regular"

        virsh reset "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d%s\\n" "$yellow" $virsh_ec "$regular"
        else
          sleep 1
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# reboot_cmd():
#   Reboots one or more active VMs
# ---------------------------------------------------------------------------

reboot_cmd() {
  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" "$red" $lowest_num_args "$regular"
    show_usage reboot 1
  fi

  all_active_VMs=$(virsh list --name 2> /dev/null)
  if [ -z "$all_active_VMs" ]; then
    printf "\\n%scannot seem to find a single active VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid VM name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_active_VMs")
      if [ "$answer" == "no" ]; then
        printf "%s%s is not an active VM%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%srebooting %s%s\\n" "$green" "$candidate" "$regular"

        virsh reboot "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d%s\\n" "$red" $virsh_ec "$regular"
        else
          sleep 1
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# unplug_cmd():
#   Forcibly powers off one or more active VMs
# ---------------------------------------------------------------------------

unplug_cmd() {
  lowest_num_args=1
  if [ $# -lt $lowest_num_args ]; then
    printf "\\n%sincorrect number of arguments (minimum is %d)%s\\n\\n" \
      "$red" $lowest_num_args "$regular"
    show_usage unplug 1
  fi

  all_active_VMs=$(virsh list --name 2> /dev/null)
  if [ -z "$all_active_VMs" ]; then
    printf "\\n%scannot seem to find a single active VM on this host%s\\n\\n" "$yellow" "$regular"
    exit 0
  fi

  for candidate; do
    answer=$(is_name_valid "$candidate")
    if [ "$answer" == "no" ]; then
      printf "%s'%s' is not a valid VM name%s\\n" "$yellow" "$candidate" "$regular"
    else
      answer=$(is_a_member "$candidate" "$all_active_VMs")
      if [ "$answer" == "no" ]; then
        printf "%s%s is not an active VM%s\\n" "$yellow" "$candidate" "$regular"
      else
        printf "%sunplugging %s%s\\n" "$green" "$candidate" "$regular"

        virsh destroy "$candidate" > /dev/null 2>&1
        virsh_ec=$?
        if [ $virsh_ec -ne 0 ]; then
          printf "%soperation failed, virsh returned error code %d%s\\n" "$yellow" $virsh_ec "$regular"
        fi
      fi
    fi
  done
}

# ---------------------------------------------------------------------------
# Main script body starts here
# ---------------------------------------------------------------------------

arg_one="$1"

if [ -z "$arg_one" ]; then
  printf "\\n%scommand not specified%s\\n" "$red" "$regular"
  show_usage "" 1
fi

if [ "$arg_one" == "help" ]; then
  show_usage "help" 0
fi

accepted_commands="activate annihilate assimilate attach check-service clone \
create deactivate define getmac list ping powcycle reboot unplug"

answer=$(is_a_member "$arg_one" "$accepted_commands")

if [ "$answer" == "no" ]; then
  printf "\\n%sinvalid command '%s'%s\\n" "$red" "$1" "$regular"
  show_usage "help" 1
fi

arg_two="$2"

if [ "$arg_two" == "help" ]; then
  echo
  show_usage "$arg_one" 0
fi

shift
case $arg_one in
  activate)
    activate_cmd "$@" ;;
  annihilate)
    annihilate_cmd "$@" ;;
  assimilate)
    assimilate_cmd "$@" ;;
  attach)
    attach_cmd "$@" ;;
  check-service)
    checkservice_cmd "$@" ;;
  clone)
    clone_cmd "$@" ;;
  create)
    create_cmd "$@" ;;
  deactivate)
    deactivate_cmd "$@" ;;
  define)
    define_cmd "$@" ;;
  getmac)
    getmac_cmd "$@" ;;
  list)
    list_cmd "$@" ;;
  ping)
    ping_cmd "$@" ;;
  powcycle)
    powcycle_cmd "$@" ;;
  reboot)
    reboot_cmd "$@" ;;
  unplug)
    unplug_cmd "$@" ;;
esac

exit 0
